<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta http-equiv="Content-Type" name="viewport" content="width=device-width, initial-scale=1"/>
<title>前端可视化建模技术概览</title>
<link rel="stylesheet" href="http://leungwensen.github.io/zfinder/dist/lib/normalize-4.2.0.min.css">

  <link rel="stylesheet" href="http://leungwensen.github.io/zfinder/dist/lib/github-markdown-2.3.0.min.css">
  <link rel="stylesheet" href="http://leungwensen.github.io/zfinder/dist/zfinder/markdown-previewer.css">
</head>
<body>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"
     style="width:0;height:0;position:absolute;overflow:hidden;">
  <defs>
    <symbol id="si-zfinder-collapse-left" viewBox="0 0 38 38">
      <path d="M38 0H0v38h38V0zM3 35V3h32v32H3zM5 5v28h17V21h-9.667L16 26h-4l-5-7 5-7h4l-3.667 5H22V5H5z"/>
    </symbol>
    <symbol id="si-zfinder-expand-right" viewBox="0 0 38 38">
      <path d="M0 0h38v38H0V0zm35 35V3H3v32h32zM22 5v28H5V21h9.667L11 26h4l5-7-5-7h-4l3.667 5H5V5h17z"/>
    </symbol>
    <symbol id="si-zfinder-fullscreen" viewBox="0 0 28 28">
      <path d="M4 18H0v10h10v-4H4v-6zm-4-8h4V4h6V0H0v10zm24 14h-6v4h10V18h-4v6zM18 0v4h6v6h4V0H18z"/>
    </symbol>
    <symbol id="si-zfinder-fullscreen-exit" viewBox="0 0 28 28">
      <path d="M0 22h6v6h4V18H0v4zM6 6H0v4h10V0H6v6zm12 22h4v-6h6v-4H18v10zm4-22V0h-4v10h10V6h-6z"/>
    </symbol>
  </defs>
</svg>
<nav id="toc">
  <div id="toc-body" class="toc-body"></div>
</nav>
<article id="markdown">
  <nav id="markdown-header" class="markdown-header">
    <svg class="si" id="toggle-toc" width="24" height="24">
      <use xlink:href="#si-zfinder-collapse-left"></use>
    </svg>
    <svg class="si float-right" id="toggle-fullscreen-article" width="24" height="24">
      <use xlink:href="#si-zfinder-fullscreen"></use>
    </svg>
  </nav>
  <div id="markdown-body" class="markdown-body"><h1>前端可视化建模技术概览</h1>
<h2>前言</h2>
<p>建模是计算机世界一个恒久的主题。根本的需求来源于“图形化展示数据、逻辑”。这个需求下我们有了ER图、流程图、UML图、BPMN图等标准，也诞生了很多经典的桌面图形建模应用，譬如<a href="http://www.microsoftstore.com.cn/%E7%B1%BB%E5%88%AB/%E8%BD%AF%E4%BB%B6%E4%B8%8E%E6%9C%8D%E5%8A%A1/c/software">visio</a>、<a href="http://www.ibm.com/software/products/en/ratirosefami/">Rational Rose</a>、<a href="http://www.yworks.com/products/yed">yEd</a>、<a href="http://www.xmind.net/">XMind</a>等等。</p>
<p>单页面应用已经不是新鲜词汇，而利用html5开发离线应用、native应用的技术方案也越来越流行。因而在前端做类似的可视化建模的需求和解决方案也越来越多。举个离我们比较近的例子：ACP里就用到流程图表示工作流程和状态。</p>
<div class="viz-graph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: validatingFlow Pages: 1 -->
<svg width="544pt" height="44pt"
 viewBox="0.00 0.00 543.55 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>validatingFlow</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-40 539.552,-40 539.552,4 -4,4"/>
<!-- a -->
<g id="node1" class="node"><title>a</title>
<ellipse fill="none" stroke="black" cx="35.1789" cy="-18" rx="35.3587" ry="18"/>
<text text-anchor="middle" x="35.1789" y="-13.8" font-family="Times,serif" font-size="14.00">开始</text>
</g>
<!-- b -->
<g id="node2" class="node"><title>b</title>
<ellipse fill="none" stroke="black" cx="146.351" cy="-18" rx="39.9857" ry="18"/>
<text text-anchor="middle" x="146.351" y="-13.8" font-family="Times,serif" font-size="14.00">审批中</text>
</g>
<!-- a&#45;&gt;b -->
<g id="edge1" class="edge"><title>a&#45;&gt;b</title>
<path fill="none" stroke="black" d="M70.422,-18C78.6019,-18 87.4932,-18 96.1982,-18"/>
<polygon fill="black" stroke="black" points="96.278,-21.5001 106.278,-18 96.2779,-14.5001 96.278,-21.5001"/>
</g>
<!-- c -->
<g id="node3" class="node"><title>c</title>
<ellipse fill="none" stroke="black" cx="264.114" cy="-18" rx="41.5427" ry="18"/>
<text text-anchor="middle" x="264.114" y="-13.8" font-family="Times,serif" font-size="14.00">已审批</text>
</g>
<!-- b&#45;&gt;c -->
<g id="edge2" class="edge"><title>b&#45;&gt;c</title>
<path fill="none" stroke="black" d="M186.543,-18C194.657,-18 203.32,-18 211.793,-18"/>
<polygon fill="black" stroke="black" points="211.985,-21.5001 221.984,-18 211.984,-14.5001 211.985,-21.5001"/>
</g>
<!-- d -->
<g id="node4" class="node"><title>d</title>
<ellipse fill="none" stroke="black" cx="392.782" cy="-18" rx="50.7952" ry="18"/>
<text text-anchor="middle" x="392.782" y="-13.8" font-family="Times,serif" font-size="14.00">已配置</text>
</g>
<!-- c&#45;&gt;d -->
<g id="edge3" class="edge"><title>c&#45;&gt;d</title>
<path fill="none" stroke="black" d="M305.89,-18C314.103,-18 322.898,-18 331.614,-18"/>
<polygon fill="black" stroke="black" points="331.768,-21.5001 341.768,-18 331.768,-14.5001 331.768,-21.5001"/>
</g>
<!-- e -->
<g id="node5" class="node"><title>e</title>
<ellipse fill="none" stroke="black" cx="507.616" cy="-18" rx="27.8725" ry="18"/>
<text text-anchor="middle" x="507.616" y="-13.8" font-family="Times,serif" font-size="14.00">结束</text>
</g>
<!-- d&#45;&gt;e -->
<g id="edge4" class="edge"><title>d&#45;&gt;e</title>
<path fill="none" stroke="black" d="M443.93,-18C452.442,-18 461.147,-18 469.257,-18"/>
<polygon fill="black" stroke="black" points="469.509,-21.5001 479.509,-18 469.509,-14.5001 469.509,-21.5001"/>
</g>
</g>
</svg>
</div>
<p>当然，具体产品线里有更复杂的例子。譬如我们团队的<a href="http://pai.yushanfang.com/">PAI</a>使用DAG来描述数据挖掘的过程。</p>
<figure><img src="./frontend-visual-modeling/pai.png" alt="PAI"></figure>
<p>下面和大家分享一下前端可视化建模方面的需求和技术方案。</p>
<h2>需求</h2>
<p>可视化建模最核心的需求就是画一个图形学上的<a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">图</a>。要么是根据用户给定的数据结构展示成可视化的图形（用svg、canvas、html+css或者混用）；要么是经过用户和系统的一系列交互，画出可视化图形后，可以生成相应的数据结构。</p>
<p>即实现如下图的可视化建模系统。</p>
<div class="viz-graph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: modeling Pages: 1 -->
<svg width="160pt" height="231pt"
 viewBox="0.00 0.00 160.49 230.60" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 226.6)">
<title>modeling</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-226.6 156.493,-226.6 156.493,4 -4,4"/>
<text text-anchor="middle" x="76.2465" y="-206" font-family="Times,serif" font-size="14.00">前端可视化建模系统</text>
<!-- a -->
<g id="node1" class="node"><title>a</title>
<ellipse fill="none" stroke="black" cx="76.2465" cy="-179.8" rx="45.2516" ry="18"/>
<text text-anchor="middle" x="76.2465" y="-175.6" font-family="Times,serif" font-size="14.00">数据结构</text>
</g>
<!-- b -->
<g id="node2" class="node"><title>b</title>
<ellipse fill="none" stroke="black" cx="76.2465" cy="-91" rx="65.5218" ry="18"/>
<text text-anchor="middle" x="76.2465" y="-86.8" font-family="Times,serif" font-size="14.00">可视化图形</text>
</g>
<!-- a&#45;&gt;b -->
<g id="edge1" class="edge"><title>a&#45;&gt;b</title>
<path fill="none" stroke="black" d="M62.8242,-162.331C59.0814,-156.778 55.514,-150.326 53.5859,-143.8 51.4702,-136.639 51.4702,-134.161 53.5859,-127 54.5294,-123.807 55.8655,-120.631 57.4226,-117.569"/>
<polygon fill="black" stroke="black" points="60.5153,-119.215 62.5856,-108.825 54.4875,-115.656 60.5153,-119.215"/>
<text text-anchor="middle" x="67.0768" y="-131.2" font-family="Times,serif" font-size="14.00">渲染</text>
</g>
<!-- b&#45;&gt;a -->
<g id="edge3" class="edge"><title>b&#45;&gt;a</title>
<path fill="none" stroke="black" d="M78.004,-109.071C78.5118,-114.766 78.9963,-121.151 79.2465,-127 79.5656,-134.46 79.5656,-136.34 79.2465,-143.8 79.137,-146.359 78.9827,-149.021 78.8012,-151.682"/>
<polygon fill="black" stroke="black" points="75.3061,-151.483 78.004,-161.729 82.2842,-152.037 75.3061,-151.483"/>
<text text-anchor="middle" x="99.8531" y="-131.2" font-family="Times,serif" font-size="14.00">转换</text>
</g>
<!-- c -->
<g id="node3" class="node"><title>c</title>
<ellipse fill="none" stroke="black" cx="76.2465" cy="-18" rx="46.1582" ry="18"/>
<text text-anchor="middle" x="76.2465" y="-13.8" font-family="Times,serif" font-size="14.00">用户交互</text>
</g>
<!-- b&#45;&gt;c -->
<g id="edge2" class="edge"><title>b&#45;&gt;c</title>
<path fill="none" stroke="black" d="M70.3683,-72.8129C69.5289,-64.7895 69.2956,-55.0475 69.6686,-46.0691"/>
<polygon fill="black" stroke="black" points="73.1643,-46.2526 70.3849,-36.0288 66.1821,-45.7544 73.1643,-46.2526"/>
</g>
<!-- c&#45;&gt;b -->
<g id="edge4" class="edge"><title>c&#45;&gt;b</title>
<path fill="none" stroke="black" d="M82.1081,-36.0288C82.9555,-44.0295 83.1967,-53.7651 82.8317,-62.7534"/>
<polygon fill="black" stroke="black" points="79.3345,-62.5921 82.1247,-72.8129 86.3172,-63.0829 79.3345,-62.5921"/>
</g>
</g>
</svg>
</div>
<h2>分析</h2>
<h3>图素</h3>
<p>上面的“前端可视化建模系统”就是一个典型的可视化图形。这个最最基础的图里包含以下基本图素：</p>
<ul>
<li>顶点(node/vertex)</li>
<li>边(link/edge)</li>
</ul>
<p>顶点表示描述的实体，边表示实体之间的关联。通过顶点和边的组合，就可以形成一个有意义的模型（图）。</p>
<p>从前端实现上可能还要抽象出来三个基本的要素：</p>
<ul>
<li>画布(canvas/graph)</li>
<li>标签(label)</li>
<li>连接桩(port)</li>
</ul>
<h3>渲染工具</h3>
<p>前面提过，前端做可视化图形可以用svg、canvas、html+css或者混用。其中，svg（或者混用html）是在这个可视化细分领域最常用的技术。因为svg里的Shapes刚好对应图里的顶点，而Paths可以对应图里的边。从实现上，svg里也有g元素可以实现画布、分组；text元素可以实现标签。甚至可以通过foreignObject内嵌html来实现复杂的顶点样式定制。事实上，上文的图正是用svg画出来的。目前应用svg实现前端建模的产品、框架很多，譬如：</p>
<ul>
<li><a href="http://nodered.org/">IBM的开源项目Node-RED</a></li>
<li><a href="https://github.com/cpettitt/dagre-d3">图形布局库dagre-d3</a></li>
<li><a href="http://marvl.infotech.monash.edu/webcola/">图形布局库cola.js</a></li>
<li><a href="https://github.com/clientIO/joint">开源画图库Joint</a></li>
<li><a href="https://github.com/sporritt/jsPlumb">开源画图库jsPlumb</a></li>
<li><a href="https://github.com/liferay/alloy-ui/tree/master/src/aui-diagram-builder">开源框架AlloyUI的画图工具</a></li>
<li><a href="http://www.jgraph.com/javascript-graph-visualization-library.html">商业画图库mxGraph</a></li>
<li><a href="http://www.draw2d.org/draw2d/home/index.html">商业画图库Draw2D</a></li>
<li><a href="https://studio.azureml.net">微软的机器学习平台上的建模工具Azure-ML</a></li>
</ul>
<p>使用canvas的相对少一些，比较出名的有:</p>
<ul>
<li><a href="http://www.nwoods.com/products/gojs/index.html">GoJS</a></li>
<li><a href="http://www.js-graph.com/">JS Graph</a></li>
<li><a href="http://getspringy.com/">Springy</a></li>
</ul>
<h2>技术方案</h2>
<p>如果只使用最基础的svg、canvas，不借助画图库的情况下，实现可视化建模是一件相当复杂的事情。这就是为什么上述列举的前端建模产品或者工具库除了Node-RED和AlloyUI暂未商业化以外，要么是闭源的（Azure-ML/mxGraph/Draw2D/GoJS/JS Graph），要么只是某个商用协议产品的社区开源版（Joint/jsPlumb），要么已经不维护了（dagre-d3）。</p>
<p>下面介绍几个在实现可视化建模时可供使用或者借鉴的项目。</p>
<h3>mxGraph</h3>
<p>这个商业产品是上述提到的可视化建模产品里最强大的一个。从05年立项至今，这个库开发时间已有十年。而它的前身JGraph立项时间更早，是2000年。虽然开发模式落后（还是绑定全局变量的方式）、体积庞大，但mxGraph的设计、功能、文档各个方面都难以挑剔。前端可视化建模的标杆作品<a href="http://draw.io">draw.io</a>以及中文作图社区<a href="https://www.processon.com/diagrams">ProcessOn</a>都是基于这个库的。基本上目前mxGraph能做到的，就是前端可视化建模能做到的。</p>
<p><a href="https://jgraph.github.io/mxgraph/javascript/examples/folding.html">demo: folding</a>。</p>
<h3>Joint</h3>
<p>Joint用jQuery维护dom，用lodash辅助计算以及渲染模版，用Backbone的Model和Events定义实体和暴露接口，并且自己实现了一套SVG渲染引擎。算得上是组合型的库。对Backbone比较熟悉的同学使用Joint上手会比较快。Joint自定义节点（使用模版）非常方便，动画相关的功能也很强大。另外，Joint还可以和布局库dagre配合使用，实现自动布局。</p>
<p>相比起mxGraph而言，Joint有几个设计或者实现上的问题：</p>
<ol>
<li>兼容性做得不够，IE9-不支持，并且在firefox低版本上有些问题</li>
<li>连接桩（port）是作为节点（node）的附属，要实现深层定制比较麻烦</li>
<li>没有做图层管理，节点的上下关系只能通过渲染顺序来决定</li>
<li>常用的缩放、画布拖拽、自动布局、交互式画图等功能都没有内置，需要自行编写（除非使用商业版）</li>
</ol>
<p>Joint作为rapid的社区版（开源版本）功能并不全面，很多时候要真正应用在项目里需要进行深入的定制。另外，其维护者对github上的issue响应速度很慢，有时候bug report也没有回应。</p>
<p>即便如此，Joint也算是可视化建模的开源库里最灵活、设计最优秀的库了。</p>
<p><a href="http://www.jointjs.com/demos/pn">demo: petri nets</a>。</p>
<h3>jsPlumb</h3>
<p>jsPlumb采用的是svg和html混排的做法，把所有节点都是html，所有连线都是单独的svg节点包裹的path元素。这么做的好处是主要是可以兼容低版本浏览器，并且节点可以充分利用css进行定制。缺点也很明显，首先文档结构散乱，很难导出、转换，其次画出来的图总有莫名的违和感，感觉是像素图形和矢量图形生硬地放到了一起，再次，一旦css在js之后加载完成，jsPlumb的图就崩溃了，而jsPlumb的css也是有侵入性的。</p>
<p><a href="https://jsplumbtoolkit.com/community/demo/statemachine/index.html">demo: state machine</a>。</p>
<h3>Alloy-UI diagrams-builder</h3>
<p>这个建模工具只建议在技术栈为YUI、并且建模需求简单时选用。Alloy-UI的设计和jsPlumb差不多，都是svg和html混排的形式。</p>
<h2>总结</h2>
<h3>常用前端可视化建模工具对比</h3>
<figure><img src="./frontend-visual-modeling/radar.png" alt="radar"></figure>
<p>以上雷达图对比的是比较成规模的，可以独立完成可视化建模的工具库。</p>
<h3>选型建议</h3>
<p>具体做技术选型时有这几个建议：</p>
<ul>
<li>个人项目可以尝试优秀的商业解决方案，体会这些强大的产品的设计</li>
<li>如果只有简单的模型展示功能，建议选用dagre-d3、Springy这样的，带自动布局、带渲染器的简单方案</li>
<li>如果有交互式建模的需求，但又不求深入定制，那可以根据开发者熟悉的技术栈选择Joint/jsPlumb/Alloy-UI等方案之一</li>
<li>如果有深入定制建模工具的需求，而且预算充足，建议和<a href="https://www.processon.com/diagrams">ProcessOn</a>一样，选择mxGraph。如果同等条件又偏好canvas，则可以考虑<a href="http://www.nwoods.com/products/gojs/index.html">GoJS</a></li>
<li>有深入定制建模工具的需求，又不允许使用商业产品，那么只剩下以下选择
<ul>
<li>基于Joint做二次开发</li>
<li>基于D3、raphael、svg.nap等实现一个可视化建模工具</li>
<li>从0开始，实现一个可视化建模工具</li>
</ul>
</li>
</ul>
</div>
</article>
<div id="loading">
  <div class="sk-double-bounce">
    <div class="sk-child sk-double-bounce1"></div>
    <div class="sk-child sk-double-bounce2"></div>
  </div>
</div>

<script src="http://leungwensen.github.io/zfinder/dist/lib/jquery-3.1.0.min.js"></script>
<script src="http://leungwensen.github.io/zfinder/dist/lib/screenfull-3.0.0.min.js"></script>
<script src="http://leungwensen.github.io/zfinder/dist/zfinder/markdown-previewer.js"></script>
</body>
</html>
