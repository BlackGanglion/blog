# 第48题 格雷码循环

IQ | 目标解题时间
----|----
110 | 40分钟

“格雷码”是一种数字编码方式。其特征是任意相邻的两个数值代码只有1个位元[^bit]不同。举个例子，一般2进制表示的“1”要变为“2”时，是由“001”变为“010”，变化2位；“3”要变为“4”，则是由“011”变为“100”，需要改变3位。而用格雷码，这两种情况都只需要改动1位（见表5）。

[^bit]: 位元：就是bit，一个二进制位

表5 格雷码示例

10进制数 | 2进制数 | 格雷码
----|----|----
0 | 000 | 000
1 | 001 | 001
2 | 010 | 011
3 | 011 | 010
4 | 100 | 110
5 | 101 | 111
6 | 110 | 101
7 | 111 | 100

下面我们试试“把n进制数转换成格雷码，把得到的编码结果看作n进制数，再一次转换成格雷码”，一直重复这个过程，直到转换为与初始值相等的值。

举个例子，当n = 2，并且初始值为100时，是“`$100\rightarrow110\rightarrow101\rightarrow111\rightarrow100$`”这样一个循环，重复转换4次后得到初始值。同样地，当n = 3，初始值为100时，转换过程则是“`$100\rightarrow120\rightarrow111\rightarrow100$`”，重复3次后回到初始值。

## 问题

**n = 16时，求从“808080”开始得到“808080”所需的转换次数，以及从“abcdef”开始得到“abcdef”所需要的转换次数。**

> 提示

> 如何求n进制数的格雷码？

> “异或”运算可以改变位元，处理n进制数也可以考虑采用异或运算。

## 思考过程

重复转换直到变为初始值这个过程不难，关键在于“如何转换成格雷码”。2进制数的格雷码比较常见，网上也有不少中文资料。但n进制数这方面的资料就寥寥无几了。

先从2进制的格雷码开始总结基本的转换模式。维基百科（[https://zh.wikipedia.org/wiki/格雷码](https://zh.wikipedia.org/wiki/格雷码)）上的资料显示，“要转换的2进制数”和“该2进制数右移1位并在最高位前补0”作异或运算的结果就是该2进制数的格雷码。

异或运算在其它问题中提过，过程如表6所示。a和b的异或相当于a和b的差除以2得到的余数。3进制数也一样，a和b的异或相当于**`$(a-b) mod 3$`**(a和b的差除以3得到的余数)（见表7）。


表6 异或运算

| 0 | 1
---- | ---- | ----
0 | 0 | 1
1 | 1 | 0

表7 异或运算（3进制下）

| 0 | 1 | 2
---- | ---- | ---- | ----
0 | 0 | 1 | 2
1 | 1 | 0 | 1
2 | 2 | 1 | 0

> 16进制数的异或运算相当于求`$(a - b) mod 16$`(a和b的差除以16得到的余数)。那1位右移又如何实现？

## 关键点

下面求“用16进制表示的10进制数”和“16进制数右移1位并在最高位前补0得到的值”的异或运算。如果10进制数是“1234”，则对应的16进制数是“4D2”，右移1为后得到“04D”，求异或得到“49B”。

下面的Ruby代码可以对每一个数位进行上述处理。16进制数在Ruby语言里以“0x”开头，这段代码就以“0x808080”和“0xabcdef”为输入值。

代码清单48.1 q48_01.rb

```ruby
N = 16
def graycode(value)
    # 分解N进制数的各个数位，存到数组中
    digits = []
    while value > 0
        digits << value % N
        value /= N
    end

    # 各个数位转换成格雷码
    (digits.size - 1).times{|i|
        digits[i] = (digits[i] - digits[i + 1]) % N
    }
    # 数组转换为数值
    digits.each_with_index.map{|d, i| d * (N**i)}.inject(:+)
end

# 一直转换直到变为初始值
def search(value)
    check = graycode(value)
    cnt = 1
    while check != value do
        check = graycode(check)
        cnt += 1
    end
    cnt
end

puts search(0x808080)
puts search(0xabcdef)
```

> 用Ruby的话，直接用to_s(16)就可以得到16进制数的字符串了，为什么不用这种方法呢？

> 的确可以用字符来表示各个数位，但相比之下用整数更贴合编码处理的需求，并且也更高效。

## 答案

**初始值为808080时需要8次**

**初始值为abcdef时需要64次**

