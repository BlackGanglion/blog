<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta http-equiv="Content-Type" name="viewport" content="width=device-width, initial-scale=1"/>
<title>第48题 格雷码循环</title>

  <link rel="stylesheet" href="http://leungwensen.github.io/zfinder/dist/lib/github-markdown-2.3.0.min.css">
  <link rel="stylesheet" href="http://leungwensen.github.io/zfinder/dist/zfinder/markdown-previewer.css">
</head>
<body>
<nav id="toc">
  <div id="toc-body" class="toc-body"></div>
</nav>
<article id="markdown">
  <div id="markdown-body" class="markdown-body"><h1>第48题 格雷码循环</h1>
<table>
<thead>
<tr>
<th>IQ</th>
<th>目标解题时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>110</td>
<td>40分钟</td>
</tr>
</tbody>
</table>
<p>“格雷码”是一种数字编码方式。其特征是任意相邻的两个数值代码只有1个位元<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>不同。举个例子，一般2进制表示的“1”要变为“2”时，是由“001”变为“010”，变化2位；“3”要变为“4”，则是由“011”变为“100”，需要改变3位。而用格雷码，这两种情况都只需要改动1位（见表5）。</p>
<p>表5 格雷码示例</p>
<table>
<thead>
<tr>
<th>10进制数</th>
<th>2进制数</th>
<th>格雷码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>000</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>001</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>011</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>010</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>101</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>下面我们试试“把n进制数转换成格雷码，把得到的编码结果看作n进制数，再一次转换成格雷码”，一直重复这个过程，直到转换为与初始值相等的值。</p>
<p>举个例子，当n = 2，并且初始值为100时，是“<code>$100\rightarrow110\rightarrow101\rightarrow111\rightarrow100$</code>”这样一个循环，重复转换4次后得到初始值。同样地，当n = 3，初始值为100时，转换过程则是“<code>$100\rightarrow120\rightarrow111\rightarrow100$</code>”，重复3次后回到初始值。</p>
<h2>问题</h2>
<p><strong>n = 16时，求从“808080”开始得到“808080”所需的转换次数，以及从“abcdef”开始得到“abcdef”所需要的转换次数。</strong></p>
<blockquote>
<p>提示</p>
</blockquote>
<blockquote>
<p>如何求n进制数的格雷码？</p>
</blockquote>
<blockquote>
<p>“异或”运算可以改变位元，处理n进制数也可以考虑采用异或运算。</p>
</blockquote>
<h2>思考过程</h2>
<p>重复转换直到变为初始值这个过程不难，关键在于“如何转换成格雷码”。2进制数的格雷码比较常见，网上也有不少中文资料。但n进制数这方面的资料就寥寥无几了。</p>
<p>先从2进制的格雷码开始总结基本的转换模式。维基百科（<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81">https://zh.wikipedia.org/wiki/格雷码</a>）上的资料显示，“要转换的2进制数”和“该2进制数右移1位并在最高位前补0”作异或运算的结果就是该2进制数的格雷码。</p>
<p>异或运算在其它问题中提过，过程如表6所示。a和b的异或相当于a和b的差除以2得到的余数。3进制数也一样，a和b的异或相当于**<code>$(a-b) mod 3$</code>**(a和b的差除以3得到的余数)（见表7）。</p>
<p>表6 异或运算</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>表7 异或运算（3进制下）</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>16进制数的异或运算相当于求<code>$(a - b) mod 16$</code>(a和b的差除以16得到的余数)。那1位右移又如何实现？</p>
</blockquote>
<h2>关键点</h2>
<p>下面求“用16进制表示的10进制数”和“16进制数右移1位并在最高位前补0得到的值”的异或运算。如果10进制数是“1234”，则对应的16进制数是“4D2”，右移1为后得到“04D”，求异或得到“49B”。</p>
<p>下面的Ruby代码可以对每一个数位进行上述处理。16进制数在Ruby语言里以“0x”开头，这段代码就以“0x808080”和“0xabcdef”为输入值。</p>
<p>代码清单48.1 q48_01.rb</p>
<pre><code class="language-ruby">N = <span class="hljs-number">16</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">graycode</span><span class="hljs-params">(value)</span></span>
    <span class="hljs-comment"># 分解N进制数的各个数位，存到数组中</span>
    digits = []
    <span class="hljs-keyword">while</span> value &gt; <span class="hljs-number">0</span>
        digits &lt;&lt; value % N
        value /= N
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># 各个数位转换成格雷码</span>
    (digits.size - <span class="hljs-number">1</span>).times{<span class="hljs-params">|i|</span>
        digits[i] = (digits[i] - digits[i + <span class="hljs-number">1</span>]) % N
    }
    <span class="hljs-comment"># 数组转换为数值</span>
    digits.each_with_index.map{<span class="hljs-params">|d, i|</span> d * (N**i)}.inject(<span class="hljs-symbol">:+</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># 一直转换直到变为初始值</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(value)</span></span>
    check = graycode(value)
    cnt = <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> check != value <span class="hljs-keyword">do</span>
        check = graycode(check)
        cnt += <span class="hljs-number">1</span>
    <span class="hljs-keyword">end</span>
    cnt
<span class="hljs-keyword">end</span>

puts search(<span class="hljs-number">0x808080</span>)
puts search(<span class="hljs-number">0xabcdef</span>)
</code></pre>
<blockquote>
<p>用Ruby的话，直接用to_s(16)就可以得到16进制数的字符串了，为什么不用这种方法呢？</p>
</blockquote>
<blockquote>
<p>的确可以用字符来表示各个数位，但相比之下用整数更贴合编码处理的需求，并且也更高效。</p>
</blockquote>
<h2>答案</h2>
<p><strong>初始值为808080时需要8次</strong></p>
<p><strong>初始值为abcdef时需要64次</strong></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>位元：就是bit，一个二进制位 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div>
</article>
<div id="loading">
  <div class="sk-double-bounce">
    <div class="sk-child sk-double-bounce1"></div>
    <div class="sk-child sk-double-bounce2"></div>
  </div>
</div>

<script src="http://leungwensen.github.io/zfinder/dist/lib/jquery-3.1.0.min.js"></script>
<script src="http://leungwensen.github.io/zfinder/dist/zfinder/markdown-previewer.js"></script>
</body>
</html>
